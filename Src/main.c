/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include "printf.h"
#include "stm32f4xx.h"

void USART_Transmit(char *niz_znakov);

// Deklaracija spremenljivk
char RxBuffer[6] = {};
uint8_t RxCount = 0;

int main(void)
{
	/************************ CLOCK CONFIG ************************/

	SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOAEN);							// Omogoci uro za port A
	SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);							// Omogoci uro za port G
	SET_BIT(RCC->APB2ENR, RCC_APB2ENR_USART1EN);							// Omogoci uro za UART1

	/************************ USART CONFIG ************************/

	//1. Enable the USART by writing the UE bit in USART_CR1 register to 1.
	SET_BIT(USART1->CR1,USART_CR1_UE);								// USART enabled

	//2. Program the M bit in USART_CR1 to define the word length.
	CLEAR_BIT(USART1->CR1,USART_CR1_M);								// 0: 1 Start bit, 8 Data bits, n Stop bit;	1: 1 Start bit, 9 Data bits, n Stop bit

	//3. Program the number of stop bits in USART_CR2.
	CLEAR_BIT(USART1->CR2,USART_CR2_STOP_0);
	CLEAR_BIT(USART1->CR2,USART_CR2_STOP_1);
	// 00: 1 Stop bit;	01: 0.5 Stop bit;	10: 2 Stop bits;	11: 1.5 Stop bit

	//4. Select DMA enable (DMAT) in USART_CR3 if Multi buffer Communication is to take
	//place. Configure the DMA register as explained in multibuffer communication.
	CLEAR_BIT(USART1->CR3,USART_CR3_DMAR);								// 0: DMA mode is disabled for reception; 1: enabled
	CLEAR_BIT(USART1->CR3,USART_CR3_DMAT);								// 0: DMA mode is disabled for transmission; 1: enabled

	//5. Select the desired baud rate using the USART_BRR register.
	//DIV_Mantissa (bit 4 do 15 v BRR): 833;  DIV_Fraction (prvi 4 biti v registru): 5 => 1200 KBps desired
	WRITE_REG(USART1->BRR, (5 << 0) | ( 833 << 4) );						//833.3125 kjer je 833 mantissa in 0,3125 fraction
													//razlaga: 0,3125 * 16 = 5 ker imamo oversampling 16
													//frakcijo vedno pomnožiš z oversampling vrednostjo

	//SET_BIT(USART1->BRR, 0x346);									//npr. lahko bi zapisali tudi v hex obliki 833+5(dec)=0x346(hex)

	//6. Set the TE bit in USART_CR1 to send an idle frame as first transmission.
	SET_BIT(USART1->CR1,USART_CR1_TE);								// 1: Transmitter is enabled
	SET_BIT(USART1->CR1,USART_CR1_RE);								// 1: Receiver is enabled and begins searching for a start bit

	// Enable interrupt
	SET_BIT(USART1->CR1,USART_CR1_RXNEIE);				//1: An USART interrupt is generated whenever ORE=1 or RXNE=1 in the USART_SR register
	//SET_BIT(USART1->CR1,USART_CR1_TXEIE);				//1: An USART interrupt is generated whenever TXE=1 in the USART_SR register
	NVIC_EnableIRQ(USART1_IRQn);


	/************************ PIN CONFIG ************************/

	// PA9 (Tx) na alternate function mode (10) => bit 2*9+1 = 19 na 1, bit 2*9 = 18 na 0
	SET_BIT(GPIOA->MODER, GPIO_MODER_MODER9_1);
	CLEAR_BIT(GPIOA->MODER, GPIO_MODER_MODER9_0);

	// PA10 (Rx) na alternate function mode (10) => bit 2*10+1 = 21 na 1, bit 2*10 = 20 na 0
	SET_BIT(GPIOA->MODER, GPIO_MODER_MODER10_1);
	CLEAR_BIT(GPIOA->MODER, GPIO_MODER_MODER10_0);

	// PG13 na output (01)
	CLEAR_BIT(GPIOG->MODER, GPIO_MODER_MODER13_1);
	SET_BIT(GPIOG->MODER, GPIO_MODER_MODER13_0);

	// PG14 na output (01)
	CLEAR_BIT(GPIOG->MODER, GPIO_MODER_MODER14_1);
	SET_BIT(GPIOG->MODER, GPIO_MODER_MODER14_0);

	// AFRH register (v  zapisemo vrednosti AFn (n, ki pripada UART => n = 7 => (0111))
	uint32_t* pAafrl = (uint32_t*)GPIOA_AFRH;					// dopisano v stm32f4xx.h stran 5814
	// PA9,  bit 7 na 0, 6 na 1, 5 na 1, 4 na 1
	SET_BIT(*pAafrl, (7<<4));

	// PA10, bit 11 na 0, 10 na 1, 9 na 1, 8 na 1
	SET_BIT(*pAafrl, (7<<8));


	USART_Transmit("Test\r\n");


		for(;;)
		{
			// BREZ PREKINITEV
	//		/******** Ukaz ********/
	//		for(i = 0; i < 6; i++)
	//		{								// Ukaz = 6 znakov, funkcija sprejme vsak znak posebej
	//			RxBuffer[i] = USART_Receive();
	//		}

			/******** Akcija in povratno sporocilo ********/
			// BREZ PREKINITEV: if(strcmp(RxBuffer,"")==0){			// Ukaz je bil sprejet (RxBuffer ni prazen)
			if(RxCount >= 6)
			{								// Sprejet je bil ukaz (6 znakov)
				if( strncmp(RxBuffer, "L13o\r\n", 6) == 0 )
				{	// 0 pomeni, da sta si znaka enaka
					SET_BIT(GPIOG->ODR, (1 << 13) );		// Vključi se LED na PG13
					USART_Transmit("Green LED ON\r\n");
				}
				else if( strncmp(RxBuffer, "L13f\r\n", 6) == 0 )
				{
					CLEAR_BIT(GPIOG->ODR, (1 << 13) );		// Izključi se LED na PG13
					USART_Transmit("Green LED OFF\r\n");
				}
				else if( strncmp(RxBuffer, "L14o\r\n", 6 ) == 0 )
				{
					SET_BIT(GPIOG->ODR , (1 << 14) );		// Vključi se LED na PG14
					USART_Transmit("Red LED ON\r\n");
				}
				else if( strncmp(RxBuffer, "L14f\r\n", 6 ) == 0 )
				{
					CLEAR_BIT(GPIOG->ODR , (1 << 14) );		// Izključi se LED na PG14
					USART_Transmit("Red LED OFF\r\n");
				}
				else							// Karkoli drugega
				{
					USART_Transmit("Neznan ukaz\r\n");
				}

				RxCount = 0;
			}

			// BREZ PREKINITEV
			//strcpy(RxBuffer, "");						// Sprazni RxBuffer (strncpy?)

		}
}


void USART_Transmit(char *niz_znakov)
{
	uint8_t znak = 0;
	//7. Write the data to send in the USART_DR register (this clears the TXE bit). Repeat this
	//for each data to be transmitted in case of single buffer.
	while(*niz_znakov)
	{										// In c string are null-terminated
		znak = *niz_znakov++;
		WRITE_REG(USART1->DR, znak);
		while(READ_BIT(USART1->SR,USART_SR_TXE) == 0){};			// TXE -> 0: Data is not transferred to the shift register;
	}
	//8. After writing the last data into the USART_DR register, wait until TC=1. This indicates
	//that the transmission of the last frame is complete. This is required for instance when
	//the USART is disabled or enters the Halt mode to avoid corrupting the last transmission.
	while(READ_BIT(USART1->SR,USART_SR_TC) == 0){};
}

	// BREZ PREKINITEV
//	char USART_Receive(void)
//{											// Funkcija vrne znak
//	while( READ_BIT(USART1->SR, USART_SR_RXNE) == 0 ){}				// Cakaj dokler znak ni sprejet
//	char znak = READ_REG(USART1->DR);
//
//	return znak;
//}


void USART1_IRQHandler(void)
{
	// V primeru RXNE interrupta (znotraj prekinitvene rutine smo zaradi prejemanja)
	if( READ_BIT(USART1->SR,USART_SR_RXNE) != 0 )
	{										// ce RX ni prazen
		char znak = READ_REG(USART1->DR);					// beri prejet znak
		RxBuffer[RxCount] = znak;
		RxCount++;
	}

	// V primeru TXE interrupta	(znotraj prekinitvene rutine smo zaradi posiljanja)
//	if( READ_BIT(USART1->SR,USART_SR_TXE) != 0 )
//	{	// ce TX ni prazen

//	}
}
